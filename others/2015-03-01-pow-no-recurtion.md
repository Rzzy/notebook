---
layout: post
title: 求幂非递归解法
category: CS
---


## 求幂非递归解法

我们知道求解一个数的N次幂，我们通常使用pow函数。需要求a^N,最最显而易见的方法是用N个a连续做乘法，所以这个算法是O(N)的，我们希望找到更加快速的算法。

最最常见的一种方法是采用递归的求解方式，如下：

### 递归解法：
```
long int pow(int x,unsigned int N){
	if(N==0){
		return 1;
	}
	if(N==1){
		return x;
	}
	if(N&1==0){
		return pow(x*x,N/2);
	}else{
		return pow(x*x,N/2)*x;
	}
}

```

这个算法无疑是O(logN)的。

下面我们希望不采用递归来求解：

**非递归解法：**

```
long int pow(int x,unsigned int N){
	int ans,n;
	ans=1;
	n=x;
	while(N!=0){
		if(N&1==1){
			ans*=n;
		}
		n*=n;
		N>>1;
	}
	return ans;
}
```

**分析如下：**

我们来举个例子先，希望求5^62，也就是5的62次方。我们直到为了算法高效那么一个原则就是不做重复的计算。

我们知道：5^62=5^(32+16+8+4+2)=5^32*5^16*5^8*5^4*5^2,这里或许看出了一点端倪，那就是指数部分是可以分解成2的倍数的和的。在看看62的二进制表现形式：

62 = 00111110B，而以上算法中的n随着循环会变成x,x^2,x^4,x^8,...我们只需要在必要的时候让他和ans相乘即可，而必要时刻就是N的二进制位数为1的时候。
