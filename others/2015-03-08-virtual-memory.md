---
title:虚拟存储器简述
---


## 虚拟存储器概述

我们知道高速缓存（cache）缓存了处理器常用的数据，以至于处理器不需要每次都从主存中读取数据或像主存中写数据。而主存也可以为磁盘充当"cache",程序不需要频繁地读取磁盘，因为磁盘中的数据缓存在了主存中。这一种将主存用作磁盘的高速缓存的技术就叫做虚拟存储器( virtual memory)。

构造虚拟储存器有两个主要动机：

1. 允许多个程序之间有效而安全地共享存储器
2. 消除一个小而受限的主存容量对程序设计造成的影响。

考虑一系列程序在一台计算机上运行的情况，为了多个程序共享同一个存储器，我们必须保护每个程序，确保程序只能对划分给它的那部分主存进行读写。主存中只需要存放众多程序中活跃的那部分，如同cache中只存放一个程序的活跃部分一样。

在编译的过程中，我们不知道程序将会和那些程序共享存储器。我们希望程序都编译到自己的**地址空间**，在运行的时候虚拟存储器实现程序地址到物理地址的转换。这种转换使得各个程序能够独立的享有一块内存。

在虚拟存储器中，处理器产生一个虚拟地址，结合软硬件转换成一个物理地址，然后就可以用来访问主存了。拿图书馆来举例，一本书的书名就是虚拟地址，而物理地址则是这本书在图书馆中的位置。
　
虚拟存储器的原理同cache一致，但是不同的历史根源决定了它们要使用不同的术语，在虚拟存储器中块被称为页，访问缺失被称为缺页。


虚拟存储器还提供重定位来简化执行时程序加载过程。在使用地址访存之前，重定位将程序使用的虚拟地址映射到不同的物理地址。重定位的方法允许我们将程序加载到主存中的任何位置。如今的虚拟储存器将程序重定位成一组固定大小的块，因此减少了在主存中寻找连续块来放置程序的必要。


```
//图1 虚拟地址到物理地址的映射

_________________________________________
|                          |              |
|        虚拟页号          |  页内偏移    |
|__________________________|______________|
			|                     |
			|                     |
			|                     |
			V                     |
		地址变换                  |
			|                     |
			|                     |
			V                     V
   ________________________________________
   |                       |               |
   |   物理页号            |    页内偏移   |
   |_______________________|_______________|

```

虚拟地址和物理地址都由两部分构成，虚拟页号经过地址变换得到物理页号，而页内偏移不变，页内偏移的位数说明了每页的大小。拥有比物理页数更多的虚拟页数是描述一个没有容量限制的虚拟存储器的假象的基础。多个虚拟页号可能映射到同一个物理页上，同多个地址可能映射到cache中的同一个块一样。

## 页的存放和查找

如果允许一个虚拟页映射到任意的物理页，由于缺页的代价很高，所以当缺页发生时操作系统可以使用复杂的算法和数据结构来来追踪页的使用情况以选择一个在较长时间内不会被使用的页进行替换。

在虚拟存储器中，使用了一个索引存储器的表来定位页，这个结构称为页表，它存在于存储器中。页表使用虚拟地址的页号作为索引以找到对应的物理页号。

每个程序都有自己的页表用来将程序的虚拟地址映射到主存中。用图书馆的例子来说，这个页表就是书名与藏书位置之间的映射。即通过该页表可以查到书在那里存放着。

页表，程序计数器，寄存器决定来一个程序的状态。如果我们希望让另一个程序使用处理器我们必须保存该状态。随后在恢复了该状态后程序就可以继续运行了。我们通常将这样的一个状态称之为一个进程。如这个进程占据了处理器那么这个进程就是活跃的，反之则是非活跃的。进程的地址空间以及它可以访问到的所有的数据都由这个页表决定。当一个进程需要被唤醒时，操作系统只是简单地加载页表寄存器指向它想要激活的进程的页表，操作系统并不保存整个页表。  



```
//图 用虚拟页号来索引页表以获得对应的物理地址部分

_________________________________________
|                          |              |
|        虚拟页号          |  页内偏移       |
|__________________________|______________|
			  |                  |
     		  |                  |
    __________|________	         |
   |_|________|________|         |
   |_|________|________|         |
页 |_|________|________|         |
表 |_|________V________|         |
   |_|_/_/_/_/_/_/_/_/_|         |
   |_|______|__________|         |
   |_|______|__________|         |
    ^ 		|                    |
    |	    |                    |
    |		|                    |
  有效位	  |                    |
			V                    |
		地址变换                  |
			|                    |
			|                    |
			V                    V
   ________________________________________
   |                       |               |
   |   物理页号            |    页内偏移   |
   |_______________________|_______________|

如果有效位为1，说明该页在主存中，如果为0则说明不在，就会发生一次缺页。
```

** 引用位 **
 　　要采用算法准确地决定替换那一页这样的代价过高，所以一些计算机提供了引用位或者是使用位，当一页被使用时该位置1，操作系统定期将所以引用位清零，然后重新记录，这样操作系统就能通过检查引用位是否为0来选择近期最少被访问的页了_*

## 缺页

当有缺页发生的时候会发生一次缺页中断，操作系统获得控制权，操作系统必须在下一级（通常是磁盘）中找到该页然后决定将该页放在主存中的什么位置。

虚拟地址不能告诉我们该页在磁盘中的什么地方，就像我们不能通过书名就找到书的具体位置，而是按照目录来查找，获得书在书架上的位置信息。操作系统在创建进程的时候，通常会在磁盘上为进程中的所有页创建空间。这一磁盘空间称为交换区。同时，操作系统也创建一个数据结构来记录每个虚拟页在磁盘上的存放位置。



```
//图3 页表将虚拟存储器中的每一页映射到主存中的一页或者存储器的下一层（磁盘）上的一页


		页表                            物理地址
 ______________________                ___________
|_1_|__________________|----------->  |___________|
|_0_|__________________|----+         |___________|
|_1_|__________________|----|------>  |___________|
|_1_|__________________|----|------>  |___________|
|_0_|__________________|--+ |         |___________|
|_1_|__________________|--|-|------>  |___________|
                          | |           
						  | |           磁盘存储
   						  | |          ___________
		                  | +-------->|___________|
		                  |           |___________|
                          +---------->|___________|
                                      |___________|

如果有效位开启，那么页表提供虚页对应的物理页号。如果有效位关闭，那么该页就存在于磁盘上的某个指定的磁盘地址。
```

## 关于写

对于高速缓存(cache),它的下一级是主存，当cache中的数据发生变化时可以采用两种措施：

1. 直接写回到主存（直写）
2. 当cache中这一块要被覆盖掉的时候写回主存（写回）

访问cache和主存的时间相差上百个时钟周期，以上两个方式都是可以使用的。但是对磁盘的写操作需要上百万个时钟周期，所以对于虚拟存储器只能采用写回机制。即只对该页进行写操作，只有在该页被换出存储器的时候再将数据复制到磁盘中。


**重写位**
了追踪读入主存中的页是否被写过，可以在页表中增加一个重写位，当该页中任何一个字被写时，这个重写位据会置位。如果操作系统要替换某一页，那么在替换前该位能够决定是否在替换前将该页写回磁盘。

## 加快地址转换:TLB

由于页表是存放在主存中的，所以程序每次访存至少需要两次：第一次访存通过虚拟地址获得物理地址，第二次访存在获得数据。所以提高页表访问局部性能提高访问性能。因为当一个虚拟页号被使用时，它可能很快会被再次使用。所以在现代处理器中都包含一个特殊的cache来追踪最近使用过的地址变换。这个特殊的地址转换cache叫做块表（TLB），也就是一个地址变换高速缓存。TLB就相当于一个小卡片上面记录了一些书名和该书在图书馆里的位置，当我们需要寻找的书在这个小卡片行的时候我们就不需要去其他地方（页表）查了。

因为虚拟地址和物理地址的页内偏移是一样的，所以TLB只需通过虚拟页号来得到物理页号，然后和虚拟地址的页内偏移合成得到物理地址。

每次访存我们都要在TLB中查找虚拟页号。如果命中那么就合成物理地址。在页表中每一项都包含有引用位和重写位，在TLB中也需要包括这些状态位。当TLB表项要被替换时，需要把这些位复制回页表项中。

```
//图4 TLB作为页表的缓存，用于存放映射到物理页中的项

               TLB

 有  重  引
 效	 写	 用
 位	 位  位    标记           物理页地址
 ___________________________________________
|__|___|___|___________|____________________|
|__|___|___|___________|____________________|
|  |   |   |           |                    |

```


## 虚拟存储器中的保护

虚拟存储器最重要的功能就是允许多个进程共享一个主存，同时为这些进程和操作系统提供存储保护。保护机制要保证，尽管多个进程共享同一个主存，但是无论是有意还是无意，一个进程不能写另一个进程或者操作系统的地址空间。

当操作系统决定从进程P1切换到进程P2的时候（上下文切换），它需要保证P2进程不能访问到P1进程的页。如果不考虑TLB那么只要把页表寄存器转而指向P2的页表就可以了。如果将TLB考虑进来，那么就需要清除掉TLB中缓存的P1的表项。如果进程切换频率很高，那么这一效率就会很低。一个做法是为每一个进程维护一个进程标识符，只有当进程标识符和页号同时匹配时才会发生TLB命中。


## 处理TLB的缺失和缺页

尽管TLB命中时，利用TLB将虚拟地址转换为物理地址很简单，但是处理TLB缺失和缺页却要复杂的多。当TLB中没有表项能够匹配虚拟地址的时候，TLB缺失就会发生。TLB缺失有下面两种情况：

1. 页在主存中：此时可以将有效的页表项复制到TLB中来解决却失。
2. 页不在主存中：如在在主存中匹配的页表项的有效位是关闭的，这说明对应的页不再主存中，这就发生了缺页。此时操作系统需要为此做一下三个步骤的工作：
  1. 使用虚拟地址查找页表项，并在磁盘上找到被访问的页的位置。
  2. 选择替换一个物理页，如果被选择的页被修改过，那么需要在把新页装入之前将这个物理页写回到磁盘上。
  3. 启动读操作，将被访问的页从磁盘上取回到所选择的物理页的位置上。


虚拟存储器机制提供了从被程序使用的虚拟地址到用来访问主存的物理地址之间的转换，这个地址转换允许对主存进行受保护的共享。为了保证进程间受到保护，要求只有操作系统才能改变地址变换，进程之间受控制地共享可以在操作系统的协助下实现，页表中的访问位被用来指出用户程序对页进行读访问还是写访问。
