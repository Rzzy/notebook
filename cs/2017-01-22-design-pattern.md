---
layout: post
title:  设计模式
category: 理解计算机
tag: 设计模式
---

* toc
{:toc}

## 设计模式的类型

- 创建型模式: 创建型模式提供了创建对象时候的一些策略。
- 结构型模式: 这些设计模式关注类和对象的组合。
- 行为型模式: 这些设计模式特别关注对象之间的通信。

## 创建型模式

### 工厂模式（Factory Pattern）

提供一个创建实例的统一接口，把不同实例的创建过程隐藏起来。工厂模式适用于创建一些同类型的复杂对象。

### 单例模式（Singleton Pattern）

单例模式是说一个类的对象只有一个，多次调用同一个构造函数应该返回同一个对象。

### 建造者模式（Builder Pattern）

建造者模式用来创建复杂的对象，这些对象的内部可能又包含多个对象，而且这些对象会频繁变动，但是整体的结构相对稳定。与工厂模式的区别在于，建造者模式更关注内部零部件的装配过程。

工厂模式通常是根据参数不同，返回不同的对象实例，而建造者则是进行不同的操作返回一个对象。

### 原型模式（Prototype Pattern）

原型模式用于创建重复的对象，并且尽可能地保证高性能。通常利用已经存在的对象来得到新的对象。

## 结构型模式

### 适配器模式（Adapter Pattern）

适配器模式用来将现有的接口转换为用户希望得到的另外一个接口。。比如使用笔记本电脑读取 SD 卡，笔记本电脑上没有直接的接口，这个时候使用一个读卡器来连接两者，这样读卡器就是一个适配器。再举个例子就是，手机充电需要 5V 而市电是 220V，需要一个适配器来转换电压。

### 桥接模式（Bridge Pattern）

将抽象部分与其实现部分分离，使它们都可以独立地变化。

### 过滤器模式（Filter Pattern）

过滤器模式是利用多个不同的类来处理同一组数据，然后根据各自不同的规则返回这组数据中的一个子集。

### 组合模式（Composite Pattern）

组合模式将对象组合成为树形结构，它将基本组件和复杂组件组合起来，构成更大的组件。比如 React 中的组件就使用了这种模式。

这些被组合的对象常常具有相同的接口，这让用户感觉不到它们是不同类的东西，用户对组合对象和简单对象的使用具有一致性。

### 装饰器模式（Decorator Pattern）

装饰器模式是向一个现有的对象中添加一些属性，不改变其原有的结构。这种模式创建一个装饰类，在保证原类的功能不变的前提下，提供额外的功能。

为了给类增加额外的功能，一个方法是使用继承，但是使用继承会导致类的继承深度增加。使用装饰器模式会创建一个装饰类，该装饰类接受一个类，被对这个类进行一些追加操作，而后返回。

### 外观模式（Facade Pattern）

外观模式用来隐藏系统内部的复杂性，提供一个简单的接口调用，屏蔽了具体实现。外观模式是在用户和系统之间增加了一层实现，统一了系统接口，使用户能够更方便地调用。

### 享元模式（Flyweight Pattern）

享元模式利用对象共享的思路来支持大量的细颗粒的对象。在应用中存在一类对象的非常多的实例的时候可以考虑使用这种模式，这样多个同类对象可以使用同一个，这会大大节省内存。在需要使用到共享对象的时候，可以将特殊的部分传入，然后让该共享对象做他该做的事情。

### 代理模式（Proxy Pattern）

为一个对象提供一个代理，使用代理来完成对该对象的控制。代理代表了这个对象，用户通过代理与这个对象进行交流，代理能够决定该怎么做。代理能够控制对象的访问。

## 行为型模式

### 责任链模式（Chain of Responsibility Pattern）

责任链模式为一个请求创建了一个接收者的链，这些接受者接收到请求然后做出处理，如果处理不了，就将请求传给下一个接收者。中间件就使用了这种模式。

### 命令模式（Command Pattern）

命名模式是一种数据驱动的模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象根据命令做出合适的操作。比如 redux 中使用的 dispatch 这就属于命令模式的思想。

### 解释器模式（Interpreter Pattern）

定义一个表达式，在调用的使用传入符合规则的表达式，解释器能够从中获知需要进行什么操作。


### 迭代器模式（Iterator Pattern）

迭代器模式提供了一个遍历集合中数据的方法，遍历的时候不需要知道底层的数据表示，用户只需要使用固定的接口，就能完成变量。比如在 JavaScript 中，用户只需要实现迭代器接口，就能对该对象进行遍历。这么做能保证，既不暴露内部数据，又能完成遍历操作。

### 中介者模式（Mediator Pattern）

作为多个类的中介，中介者负责各个类之间的沟通，在没有中介者的时候各个类之间的连接关系是网状结构，有了中介者就变成了星型结构。

### 备忘录模式（Memento Pattern）

备忘录模式使用一个对象来保存多个对象的状态，然后在合适的时候根据备忘录上的信息来执行一些操作。比如记录用户的操作步骤，记录用户的击键顺序等。

### 观察者模式（Observer Pattern）

当对象间存在一对多的依赖关系时，可以使用观察者模式，比如当一个对象的状态改变，所有依赖这个状态的对象都得到通知，并自动更新。常常也称为订阅/发布模式。

### 状态模式（State Pattern）

方法的行为根据状态的改变而改变，该方法会对不同的状态有不同的表现，因此在控制该方法的表现的时候只需要改变它的状态就好了。

### 策略模式（Strategy Pattern

定义一系列的处理方法，并将这些方法封装起来，在运行式可以动态采用不同的方法。这种模式可以使算法独立出来。处理某个任务可能有多种方式，将这些方式抽出来，根据环境选用最合适的。

### 模板模式（Template Pattern

模板模式定义了一个操作中算法骨架，这使得用户可以不改变算法的结构，而定义算法中的某些特定步骤。通常是定义好了一些方法，并规定好了输入输出，这样用户就可以自己实现这些方法，只需要保证正确的输入和输出就好了。

### 访问者模式（Visitor Pattern）

访问者模式让数据接受一个访问者，并将访问者需要的数据传给了访问者，这样访问者就能根据这些数据进行一些操作。不同的访问者可以接受不同的数据进行不要的操作。这种模式解决的大量数据，以及数据处理方法之间的耦合。

比如，要处理 babel 生成的抽象语法树，就需要使用访问者模式，使用不同的访问者接收到不同的类型的节点。
